# 一：任务安排时间表



| **八月 · August** | **星期日**                                                   | **星期一** | **星期二**                             | **星期三** | **星期四**                             | **星期五**                                            | **星期六**                                                   |
| :---------------- | :----------------------------------------------------------- | :--------- | :------------------------------------- | :--------- | :------------------------------------- | :---------------------------------------------------- | :----------------------------------------------------------- |
| **周次**          | **27**                                                       | **28**     | **29**                                 | **30**     | **31**                                 | **1**                                                 | **2**                                                        |
| **第31周**        |                                                              |            |                                        |            |                                        | 建军节                                                |                                                              |
| **周次**          | **3**                                                        | **4**      | **5**                                  | **6**      | **7**                                  | **8**                                                 | **9**                                                        |
| **第32周**        |                                                              |            |                                        |            |                                        | 立秋                                                  |                                                              |
| **周次**          | **10**                                                       | **11**     | **12**                                 | **13**     | **14**                                 | **15**                                                | **16**                                                       |
| **第33周**        |                                                              |            |                                        |            |                                        |                                                       |                                                              |
| **周次**          | **17**                                                       | **18**     | **19**                                 | **20**     | **21**                                 | **22**                                                | **23**                                                       |
| **第34周**        |                                                              |            |                                        |            |                                        |                                                       | 美团笔试（上午） 10:00:00 -- 12:00:00  小米（下午） 16:00 -17：30   （京东顺延了） 晚上6.15小鹏一面 |
| **周次**          | **24**                                                       | **25**     | **26**                                 | **27**     | **28**                                 | **29**                                                | **30**                                                       |
| **第35周**        | 文远知行笔试（晚上）                                                     2025-08-24 19:00:00                          2025-08-24 21:00:00 |            | 海尔测评三天内，零跑汽车笔试三天内完成 |            | 收到北方华创的电话约面没有时间等通知。 | 汇顶科技笔试2025年08月29日 19:00~2025年08月29日 21:00 | 下午两点半；面试零跑汽车大约半个小时。2：30   ， 晚上7：00-800京东笔试   (8月) 做个海尔英语测评吧，在投点简历 做个柏楚电子的笔试吧； |
| **周次**          | 31                                                           | **1**      | **2**                                  | **3**      | **4**                                  | **5**                                                 | **6**                                                        |
| **第36周**        |                                                              | (9月)      | (9月)                                  | (9月)      | (9月)                                  | (9月)                                                 | (9月)                                                        |





| **九月 · September** | **星期日**                                                   | **星期一**                                                | **星期二**                                                   | **星期三**                                                   | **星期四**                           | **星期五** | **星期六** |
| -------------------- | ------------------------------------------------------------ | --------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------ | ---------- | ---------- |
| **周次**             | **31**                                                       | **1**                                                     | **2**                                                        | **3**                                                        | **4**                                | **5**      | **6**      |
| **第36周**           | 泰凌微电子 晚上八点半                              摩尔线程 早八点到晚八点      海康测评 | 小鹏下午的面试：2025-09-01 16:55 (GMT+08:00) 海康威视测评 | 华创面试下午四点浙江大华技术股份有限公司邀请您参加在线测评。传音控股在线测评 | 立医疗软件工程师（C++）岗位**笔试链接生效时间：**2025-09-03 17:00:00 **笔试链接失效时间：**2025-09-03 19:30:00 | 汇顶科技面试： 2025-09-04 周四 19:00 |            |            |
| **周次**             | **7**                                                        | 8                                                         | 9                                                            | 10                                                           | 11                                   | 12         | 13         |
| **第37周**           |                                                              | 小米视频面试：2025-09-08 09:00                            |                                                              |                                                              |                                      |            |            |
| **周次**             | **14**                                                       | **15**                                                    | **16**                                                       | **17**                                                       | **18**                               | **19**     | **20**     |
| **第38周**           |                                                              |                                                           |                                                              |                                                              |                                      |            |            |
| **周次**             | **21**                                                       | **22**                                                    | **23**                                                       | **24**                                                       | **25**                               | **26**     | **27**     |
| **第39周**           |                                                              |                                                           | 秋分                                                         |                                                              |                                      |            |            |
| **周次**             | **28**                                                       | **29**                                                    | **30**                                                       | **1**                                                        | **2**                                | **3**      | **4**      |
| **第40周**           |                                                              |                                                           |                                                              | (10月)                                                       | (10月)                               | (10月)     | (10月)     |





# 南芯半导体-上海





## 一轮- AI面 5025-8-23:59之前完成面试



（1）自我介绍。重点介绍项目，2min


面试官您好，我是靳可心，本科毕业于东华大学自动化系，目前在山东大学控制科学与工程学院攻读控制工程硕士。

我的核心能力是嵌入式实时操作系统、多源数据融合控制、协议解析与机器人智能交互。从本科到现在，我做过四个项目，涵盖了 MCU 级 RTOS 控制，到基于 LLM 的机器人高层智能控制。

第一块能力，是基于 RTOS 的多任务并发处理。
在“双车协同”项目中，我利用线程分层设计和优先级管理完成两辆车传球动作控制在两秒内，实现双车通信、元素处理、控制任务互不干扰。

在“K210 垃圾巡检”项目中，把相机采集、物品识别、GPS定位、SD卡存储任务解耦，通过双缓 + DMA + 事件机制实现图片写入 SD 卡稳定在 125ms 内，不阻塞主流程。

第二块能力，是总线通信与协议解析的结构化设计。
我实现 UART/I2C/SPI 驱动 + DMA/IDLE/环形缓冲 + 状态机解析模式。
在双车协同中，支持不定长帧 + CRC16校验，成功解析双车间通信消息，保证 2 秒动作窗口同步和稳定。

在巡检项目中，我分别实现了 UBlox GPS 数据解析和手机蓝牙指令解析，通过多状态机和有效性判定，使定位和指令通信更稳定可靠。

第三块能力，是软硬件与智能控制层的融合扩展。
在“机器人智能抓取”和“技能迁移”两个研究型项目中，我将 ROS、Qt、LLM 与强化学习结合：一方面，实现了自然语言到机器人动作的语义解析；另一方面，通过“语义→奖励”映射提升奖励函数生成效率，构建迁移学习网络，使新任务学习速度大大提高。

技术上，我熟悉 C/C++、Python、RT-Thread、了解Linux 驱动基础、ROS，以及常用调试与性能分析方法。
我希望能在贵司的底层软件与嵌入式平台上，继续沉淀这套系统化方法，交付稳定、可扩展、易维护的模块。谢谢。





```
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读硕士学位，本科毕业于东华大学自动化专业，并通过保研来到山大继续深造。

我的技术方向主要集中在嵌入式系统与软件开发方面。能够熟练使用 C/C++ 进行开发，对实时操作系统如 RT-Thread有实际项目经验。同时也熟悉一些基础的 Linux 驱动开发。
在硬件层面，我接触过 STM32 等 Cortex-M 系列 MCU，熟悉常用外设接口和通信协议，例如 UART、I2C 和 SPI。

在之前的项目中，我积累了一定的系统设计与实战经验。比如在双车协同控制系统中，我基于 RT-Thread 设计了一套高实时性的协同架构，通过多传感器数据融合，实现了三轮车与直立车的同控制，最终精准完成传球任务。该系统充分利用了 RT-Thread 的线程分层与优先级机制，协调图像处理、电机控制、传感器采集、LCD 监控和机间通信等多个任务并行运行。在通信层面，我采用 UART+DMA+IDLE 接收与环形缓冲区结合状态机的解析机制，实现了支持不定长帧和 CRC16 校验的可靠通信协议，并通过事件组灵活触发不同控制模式，保障双车协作的实时性和稳定性。

我注意到贵岗位需要负责MCU产品线的固件开发和电路设计，这与我之前做的嵌入式系统项目非常契合。在项目中我不仅完成了核心功能的开发，还特别注重代码的可维护性和稳定性，比如通过模块化设计和状态机机制提升代码质量。同时我也积累了程序调试经验，能够快速定位程序问题。我相信这些经验能够帮助我快速胜任贵岗位的工作。
```



（2）你的职业规划？哪几点原因让你选择南芯？对公司和岗位有怎样的了解？

```
我的职业规划是希望在嵌入式软件领域持续深耕发展。短期内，我希望能快速融入团队，深入掌握公司MCU产品线的开发流程和技术要点，为项目贡献自己的力量。中长期来看，我希望能够逐步承担更重要的开发任务，参与系统架构设计，最终成长为一名能够独立解决复杂技术问题的嵌入式系统专家。

我选择南芯主要基于以下方面考虑：首先，南芯在电源管理和MCU领域的技术实力和行业地位有目共睹，为我们提供了很高的技术平台；其次，公司正处于快速发展阶段，这为我们年轻人提供了宝贵的成长机会和发挥空间，相信在这里能与优秀的同事们共同攻克有价值的技术难题。

我对这个岗位的理解是，它需要扎实的MCU软硬件开发能力、系统级问题分析能力和良好的文档编写能力。
贵司对代码质量和系统稳定性的重视令我十分认同。我在之前的项目中不仅独立完成过固件开发与调试工作，还特别注重通过模块化设计和状态机等机制提升代码质量，同时具备硬件调试和文档编写经验。相信这些经历能够让我快速胜任岗位要求，为团队创造价值。
```

(3) 高压状态下持续输出的经历

```
在本科期间，我参与了一个双车协同控制的项目，需要在截止日期前独立完成从硬件调试到算法实现的全部工作。当时我白天还要上专业课，因此主要的开发工作都集中在晚上，经常每天只睡4到5个小时，确实承受了不小的压力。

为了高效推进项目，我们首先将整个系统拆解为几个核心模块，包括图像处理、电机控制、传感器采集、机间通信和LCD监控等，并为每个模块设定了明确的周度和每日目标。这种方式让我们即便在高强度的工作中，也能持续看到阶段性的成果，有效保持了动力。

团队还坚持每晚进行15分钟的站会，同步进度、交流遇到的问题，并互相鼓励。这段经历不仅让我学会了在高压环境下保持专注、稳步推进工作，也锻炼了解决复杂工程问题的能力，最终我们顺利完成了项目。

```

### 双车项目

(4) 遇到的困难与解决   



```
在调试双车协同项目时，一个令我印象非常深刻的困难出现在速度环和方向环的整定阶段。当时基础调试已在实验环境下完成，但一上实际赛道，就发现小车在低速时还能正常循迹，一旦速度提升，就会因响应滞后发生剧烈振荡，最终冲出道外。

我们首先怀疑是PID参数调节不当，反复调整了多次比例、积分和微分参数，但效果甚微。为了彻底定位问题，我们尝试关闭速度环，仅测试方向环的控制效果，结果发现小车在小角度偏转时能够回正，但大角度时依然无法稳定。

随后我们开始排查硬件问题，检查了电机驱动性能、编码器反馈信号和电源稳定性，却仍未找到根本原因。在接近两周的高强度排查后，我们最终决定逐行审查代码。结果发现，在控制中断服务函数中误加入了一条printf调试输出语句，严重影响了控制的实时性——尽管它看起来只是一行简单的日志。

删除该语句后，系统实时性得到显著提升，双车最终实现了稳定快速的协同循迹。
当时作为初学者，我们对嵌入式实时性的理解还不够深入，犯了这个比较低级的错误。最初加printf只是为了调试方便，完全没有意识到它会在高频中断中带来这么大的性能开销。这段经历让我深刻体会到，嵌入式开发中看似微小的代码细节，在实际运行时都可能对系统产生重大影响，也让我从此特别关注中断函数的简洁性和实时性能优化。
```

5）是否请求帮助

```
在项目中出现高速振荡问题时，我们确实主动向师兄和线上社区寻求了帮助。得到的建议多集中在PID参数整定和硬件层面，例如：
“重新整定PID参数，特别注意微分项”；
“检查电机供电是否稳定，编码器信号是否有噪声”；
“用示波器看看PWM波形是否干净”。
我们认真尝试了这些方向：反复调节了PID参数、检查了电源和信号质量、甚至重新布局了电机驱动线路，但问题依然存在。

在通用建议无法解决问题后，我们决定回归代码层面，采用最基础但彻底的方法——逐行注释和分段测试。最终发现中断服务函数中一个用于调试的printf语句严重影响了系统实时性。删除后，系统性能立刻恢复正常。
这个过程让我深刻认识到：
外部建议有助于拓宽思路，但解决复杂问题往往需要自己深入细节；
嵌入式开发中，软件细节对实时性的影响可能比算法和硬件更隐蔽；
扎实的调试能力和不放弃的耐心，才是解决底层技术问题的关键。
```

### 单车K210项目

4) 遇到的困难与解决   

控制代码不是我做的，控制代码是别的同学在硬件定时中断中完成的，图像识别也是别的同学完成的。我主要完成剩下的任务，比如通信协议，RTT系统设计线程优先级，SD卡驱动，写入检测结果

- 我负责：系统总体调度结构、线程优先级策略、通信协议栈、事件机制、SD卡存储链路、检测结果组织与可靠写入                                 我主要把多源实时任务下的通信解析、线程调度和高延迟 SD 写入这几条“易互相干扰”的链路拆开，通过事件驱动 + 双缓冲 + 低优先级后台写策略，做到指令响应稳定、检测结果可靠落盘，同时不给控制与推理主链路添阻力。

```c
我在这个项目里遇到的最大难题是系统任务调度和实时性的平衡问题。

具体来说，我们系统有摄像头识别任务、GPS解析、蓝牙指令解析、SD卡写入这几个任务并行执行。最开始我设计时比较粗糙，把这些任务都设成差不多的优先级，结果出现了明显的问题：

首先是响应延迟：手机发控制指令过来，特别是在SD卡写文件的时候，延迟更严重。

然后是帧率不稳定：摄像头目标是15FPS，但经常掉到6-8FPS，而且很不均匀。

//还有蓝牙丢包：高频发指令时，我发现环形缓冲区的溢出计数在快速增长，说明数据在丢失。

我是这样排查的：先在关键路径打时间戳，发现SD写入时间在几十毫秒，而且这期间其他任务基本停滞。再仔细看代码，发现几个问题：一是任务优先级太平，SD卡阻塞其他任务，三是UART中断回调里做了太多解析工作。

解决方案是重新设计任务架构：

我把任务分成：硬实时（中断处理）、软实时（摄像头、协议解析、SD写入）。摄像头线程优先级最高，GPS和蓝牙解析其次，SD写入最低。

关键改进是把中断处理"瘦身"：摄像头中断只做三件事——清标志、翻双缓冲索引、发信号量，不再做任何业务逻辑。图像识别工作放到图像线程中。  蓝牙中断也只是把字节搬到环形缓冲区，真正的协议解析放到专门的线程里用状态机一个字节一个字节处理。

数据流重新设计：用事件机制代替轮询，比如只有检测到垃圾才触发SD写入事件。由于之前的写入与摄像头识别线程共用一个检测结果数据，写入前先把检测结果和GPS坐标"快照"到局部变量，立即释放锁，然后慢慢写文件，这样不会阻塞其他任务。

效果很明显：整个系统运行平顺了很多。

这个经验让我深刻理解了在资源受限的嵌入式系统上，任务优先级设计和中断处理瘦身的重要性，还有就是一定要用数据说话，不能凭感觉调优。
```





(6) 借助外部标准和多元意见


```c
城市垃圾巡检项目早期，我自己写了个简单的通信协议，能用，但扩展性差，错误处理也不完善。
团队内部讨论有人提了这个问题，我就去参考了开源项目的成熟通信协议，写了封包  解包  状态机   校验。 
    
我还请了两位有车载通信经验的导师帮我审查代码，并在修改后做了高负载压力测试。
最终协议稳定性提升很明显，后续加新功能几乎不用动底层。这个经历让我一直记得，对标成熟标准、主动听取不同领域的意见，是提升工程品质最快的方式。
```





# 小鹏一面



## 自我介绍

```c
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读硕士学位，本科毕业于东华大学自动化专业，并通过保研来到山大继续深造。

我的技术方向主要集中在嵌入式系统与软件开发方面。能够熟练使用 C/C++ 进行编程，对实时操作系统如 RT-Thread有实际项目经验。同时也了解一些基础的 Linux 驱动开发流程。在硬件层面，我接触过 STM32  Cortex-M 系列 MCU，熟悉常用外设接口和通信协议，例如 UART、I2C 和 SPI。

在之前的项目中，我积累了一定的系统设计与实战经验。比如在双车协同控制系统中，我基于 RT-Thread 设计了一套高实时性的协同架构，通过多传感器数据融合，实现了三轮车与直立车的同控制，最终精准完成传球任务。该系统充分利用了 RT-Thread 的线程分层与优先级机制，协调图像处理、电机控制、传感器采集、LCD 监控和机间通信等多个任务并行运行。在通信层面，我采用 UART+DMA+IDLE 接收与环形缓冲区结合状态机的解析机制，实现了支持不定长帧和 CRC16 校验的可靠通信协议，并通过事件组灵活触发不同控制模式，保障双车协作的实时性和稳定性。

在项目中我不仅完成了核心功能的开发，还特别注重代码的可维护性和稳定性，比如通过模块化设计和状态机机制提升代码质量。同时我也积累了程序调试经验，能够快速定位程序问题。我相信这些经验能够帮助我快速胜任贵岗位的工作。
```



## 第一个项目  基于智能交互的机器人综合抓取平台

### 描述一下这个项目：

本项目是国家自然科学基金课题的一部分，主要围绕三个核心任务：一是构建行为认知图谱，二是多任务行为规划与决策，三是我重点参与的面向智能自主作业的迁移强化学习相关内容。

为了整合并验证这几个模块的功能，需要搭建了一个集成化的可视化实验平台。就是我负责的项目一，    这个平台基于ROS、QT和大型语言模型（LLM）开发，能够实现从自然语言指令输入，经过LLM解析与任务规划，再到机器人自主执行的一整套闭环流程，整体上体现了较强的智能化特点。





### 分工：

在整个抓取平台的开发中，我主要负责可视化界面、仿真机器人与交互界面之间的通信模块，以及部分中间件的实现。后续我们计划将知识图谱集成至远程Dify平台，这部分由另一位同学负责。值得一提的是，在我实现的LLM任务规划模块中，需要依赖该同学构建的行为认知图谱信息进行决策指导。



### 项目重难点：

**首先，最大的技术难点在于异构系统的整合与异步通信架构的设计。** 整个项目需要协调 QT（C++）、ROS（C++/Python）和基于 Web API 的 HTTP/JSON 服务这三种差异较大的技术栈。其中最关键的挑战是**必须确保主UI线程绝不阻塞**，任何耗时操作都不应影响界面响应，否则会导致界面卡顿甚至无响应。

具体来说，存在两方面的阻塞风险：

- **ROS 自身的阻塞机制**：例如 `ros::spin()` 在默认情况下会占用线程以处理消息；

- **网络请求的延迟**：尤其是调用大语言模型（LLM）的 HTTP 请求，受网络状况影响，属于高延迟操作。

为解决这些问题，我设计并实现了一套**彻底的多线程架构**：

1. **主UI线程**：仅处理界面渲染和用户交互事件，确保前端流畅运行；
2. **专用ROS通信线程**：将 ROS 的初始化、订阅和发布等功能封装于独立的 `RosThread` 中，使 `ros::spin()` 在后台持续运行；
3. **LLM网络请求线程**：使用单独的 Worker 线程处理所有网络操作，基于 `QNetworkAccessManager` 执行异步HTTP请求。

这三个线程之间的通信完全依赖 **Qt 的信号与槽机制**，并统一采用 `Qt::QueuedConnection` 方式进行连接，从而实现了线程安全的跨线程数据传递。这一架构不仅有效保障了UI的流畅性，也大幅降低了模块间的耦合度，提升了系统的可维护性与扩展性。

### 嵌入式的点在哪里

1. 这个项目的嵌入式特点主要体现在三个方面：

   简单来说，虽然现在是仿真，但整个系统从设计到实现都在为最终嵌入到实体机器人做准备。

   1. **架构设计**：采用了多线程和异步通信机制，专门避免阻塞主线程，这是嵌入式开发保证实时性的常用策略。
   2. **通信协议**：中间件支持UART/SPI等嵌入式常用协议，数据交换轻量高效，方便后续移植到真实嵌入式设备。
   3. **部署适配**：LLM和算法模块在设计时已考虑嵌入式部署需求，未来可平滑过渡到硬件在环测试，并支持模型量化等优化手段。

   

## 面向任务适应的机器人操作技能学习

为了实现国家自然科学基金的第三点要求：面向智能自主作业的迁移强化学习。进行了第三点项目的深入研究。简单来说就是人类学习抓取操作具备举一反三的能力，并把在其它任务中学会的技能应用于新人无形中，但是机器人学习一项新任务往往需要从头学习，所以我的研究是如何让机器人利用已有的任务经验加速新技能的学习过程。

基于这一目的提出了一种融合 LLM 与 DRL 的创新方法，实现了工业机器人历史技能的快速迁移，显著提升了新任务的学习效率。

首先：提出基于层次化语言理解的动态奖励架构，构建 LLaMA 微调框架，实现任务语义到奖励信号的映射，任务理解准确率提高34%；

这里的背景是机器人学习任务一般需要通过基于强化学习奖励函数进行不断地试错学习，以往的机器人任务学习往往采用人力手动设计奖励函数这是十分困难的耗时的。更先进的方法是采用LLLM 去生成奖励函数，而我的创新是使用自定义的 任务指令-》奖励组件数据集微调LLAMA大模型使其具备精准的奖励组件生成能力，实验证明经过我们微调后的LLM具备更准确的任务理解能力。

第二点主要是利用上一点生成的奖励组件，提示奖励生成LLM 更精准的生成奖励函数，并自带反馈机制实现动态奖励的生成与优化。

第三点：前两点都是在说一个机器人怎么学会自己学习一个任务通过制定较优的奖励函数进行引导。那么第三点就是说如何实现利用已有经验加速新任务的学习，主要是设计了一个迁移网络，提取原技能的特征融合到新技能中，实现跨任务的迁移，达到速度提升。

![image-20250822210213566](assets/image-20250822210213566.png)

虽然当前以仿真形式呈现，但整个系统的通信中间件、任务调度机制和硬件接口层均采用嵌入式设计中常见的低资源占用和实时性策略，为后续迁移到真实嵌入式平台（如ARM Cortex-A/M系列或ROS嵌入式设备）奠定基础。

难点：就是网络如何设计，如何实现。横向迁移。



虽然现在是在电脑上仿真验证，但这个方法特别适合将来放到真实的嵌入式机器人里用，因为：

第一，它不需要太强的算力，学习新任务时不需要重新训练，很适合嵌入式设备有限的计算资源；

第二，整个算法框架设计得很轻量，容易移植到实际的机器人控制器里；

第三，它能减少机器人的试错次数和学习时间，这在真实环境中特别重要，毕竟现实中不能让机器人一直瞎折腾。

简单来说，我们不仅让机器人变得更"聪明"，还让这个方法更容易在真实的嵌入式机器人上落地使用。





## 城市垃圾智能巡检单车

### 描述：

这个项目是大学期间申请的一个创新创业项目，整个项目是从硬件设计到软件实现都是由我和其他两个队友实现的，整个项目目的主要是想基于K210开发板和单车构建一个小范围的垃圾巡检系统，整个车通过固定路径或者遥控模式巡检城市垃圾，利用摄像头采集图片，并实时识别，利用GPS进行定位，当将测到垃圾时将整张图片包括垃圾类型、识别框、位置都记录下来然后保存到SD卡中。



### 分工：

我们的团队分工明确，配合也很默契。硬件部分由一位队友负责，包括车体的机械结构设计和驱动板、主控板的PCB绘制。还有一位队友专注于图像识别算法的开发，以及车体的实时运动控制。我主要负责软件方面，包括基于RT-Thread的系统架构设计、各模块间的通信协调，以及部分设备驱动的移植和适配工作。

### 技术要点详解



第一点：基于 RTT 与双缓机制开发图像处理架构，实现图像采集、目标检测与数据存储任务的并发执行，并支持道路巡航的实时识别；

主要有图像处理线程、GPS解析线程、蓝牙指令解析线程、SD卡写入线程。 图像的采集是在中断中执行的，并不能在中断进行识别检测，中断只负责请标志位，翻转双缓冲区，开启下一次DMA采集，发送信号量给图像识别线程。由图像识别线程接收到信号，进行识别，一旦是别到垃圾就上锁保护的写全局共享的检测结果然后解锁，发送有垃圾事件，。



第二点：基于 UART + FIFO 缓冲实现手机巡检指令实时解析与响应，并通过 RTT 事件机制触发小车运动模式切换与路径点动态设置；

主要实现的是手机蓝牙与单片机之间的通信，我设计了一个可靠的通信协议；用于解析不同的控制指令，比如是控制模式还是定点循迹模式，还是设置路径点。解析状态机根据指令设置响应的事件标志位灵活触发小车运动模式？（为什么设计这个，是会丢包吗）。

![image-20250822215045443](assets/image-20250822215045443.png)

是的，您理解得非常准确。设计自定义通信协议的核心原因，正是为了解决像您提到的这些简单协议所无法处理的可靠性问题。在您的项目中，设计一个可靠的协议是非常必要且正确的做法。

您提到的参考内容完美地解释了原因，在您的蓝牙通信场景中，这些问题具体表现为：

1. **抗干扰与数据校验（解决“能否信”）**：蓝牙通信环境可能存在干扰，导致数据位错误。简单的协议没有校验机制，单片机可能无法察觉，从而执行错误的指令。您的协议需要加入**校验位（如CRC或Checksum）**，用于验证数据的完整性，确保收到的数据是准确的。
2. **数据完整性（解决“是否全”）**：蓝牙传输的数据包可能因为信号不稳定等原因发生丢失。如果没有**数据包序号**，手机端发送了多条指令，但单片机可能只收到了其中一部分，它自己却无法发现指令已经丢失，从而导致任务执行出错。序号可以帮助双方确认有没有丢包。
3. **协议扩展性与指令管理（解决“怎么用”）**：
   - **指令类型**：需要一个字段来区分这是**运动控制指令**、**路径点设置指令**还是**系统查询指令**，而不是所有数据都混为一谈。
   - **数据长度**：如果指令所附带的参数长度是可变的（例如，后续可能需要传输更复杂的路径点信息），就必须有一个**长度字段**，这样接收方才能知道一个完整的数据包在哪里结束，从而正确解析，避免数据错乱。



### 问题

1. 基于 RTT 与双缓机制开发图像处理架构，实现图像采集、目标检测与数据存储任务的并发执行，并支持道路巡航的实时识别；

说说双缓机制  怎么并发执行，

由于图像采集是在DMA进行的单次采集（循环模式  单次模式），图像处理需要用到DMA采集的图像，如果只用一帧图像的话，可能发生图像正在使用的时候发生下一次DMA搬运污染图像数据，造成错帧的现象。我才用双缓就是AB 两帧 600*600的大小，在DMA中进行AB贞的翻转，假如是采集B帧完成，下一次存到A帧，发送信号量给图像处理线程，图像处理线程收到信号量获取B帧图像处理，下一次处理A帧，然后开启下一次的DMA传输，紧接着进行图像识别的操作，这样可以做到图像采集和目标检测的并行执行，大大提高CPU的利用率。  数据存储是接收目标检测识别到之后发送检测到的event标志位，然后再存储线程中存储图片，600X**600**X3 大小。 SPI速度

 ![image-20250830113732997](assets/image-20250830113732997.png)

2. 基于 UART + FIFO 缓冲实现手机巡检指令实时解析与响应，并通过 RTT 事件机制触发小车运动模式切换与路径点动态设置； （没有用驱动的fifo）

   手机端下载一个蓝牙调试助手，设置好对应的数据结构，然后发送，在k210的串口接收中断中接收数据，存储到fifo中，并发送信号量给数据解析线程（一个字节一个字节的收和sem,sem++,）在解析线程中通过状态解析机进行解析首先 帧头0xAA,命令字节cmd，数据长度lenth，根据数据位接收数据长度，进行crc16的高低位校验，帧尾检测0x55;

   然后根据命令字节判断是，还是使用预设路径还是蓝牙控制模式，也可以设计期望路径点。（double 经纬）

3. 基于 UART + UBlox 协议实现 CUAV Neo3 GPS 驱动，通过多线程状态机解析实现定位数据获取与解析，提供实时位置服务；

​	移植的 GPS自带的ublox协议，定义了数据的消息结构ublox 

​	固定   同步字符1 0xB5

​		  同步字符2 0x62

​		  消息类别

​		消息ID

​		载荷长度 legth

​		载荷数据 payload[UBLOX_MAX_PAYLOAD_LEN]

​		校验和A

​		校验和B    checksum校验 

初始化驱动函数： 1. 分配gps驱动结构体（uart设备句柄，解析线程，互斥锁信号量，接收缓冲区，解析状态机，gps数据） 2. 初始化为0 3. 查找uart设备 rt_device_find(name),4. 配置uart参数波特兰，校验位等（struct serial_configure config）rt_device_control 进行配置，5.打开uart设备中断接收模式，读写模式 rt_device_open() 6. 设置接受回调函数 6. 创建解析线程 7. */\* 发送配置命令：设置10Hz更新率 \*/*   rt_device_write(g_cuav_neo3_dev->uart_device, 0, *cmd*, *len*);

主要就是find 查找uart 设备，绑定，通过uart的接收中断读取gps数据，通过rt_device_write写命令配置gps.

 

数据解析线程：

1）uart中断回调：*/\* UART接收回调函数 - 基于RT-Thread FIFO机制 \*/*  */\* 通过信号量通知解析线程处理数据 \*/*

  rt_sem_release(gps_dev->data_sem);

2） */\* 等待UART数据到达信号量 \*/*

​    if (rt_sem_take(dev->data_sem, RT_WAITING_FOREVER) == RT_EOK) {

​      */\* 从UART FIFO读取数据    驱动中有fifo\*/*

​      read_len = rt_device_read(dev->uart_device, 0, rx_buffer, sizeof(rx_buffer));

​	        */\* 逐字节解析UBlox协议 \*/*

​        for (rt_size_t i = 0; i < read_len; i++) {

​          ublox_parse_byte(dev, rx_buffer[i]);-》     

3） */\* 校验成功，处理消息 \*/*

​        ublox_process_message(*dev*, &*dev*->current_msg);

​        }



​       }      



4. 基于 DMA + 完成量机制构建 SD/SPI/FATFS 阻塞式读写驱动，实现巡检照片高效写入至 SD 卡（单张图片写入耗时**125ms**）。

这部分也是移植的驱动 k210之前没有SDIO的控制器，只能采用SPI进行驱动写，其中SD的驱动主要是在SPI的xfer函数上进行进一步封装的。

DMA和完成量机制主要是等待SPI的DMA完成传输的一个标志。

（完成量和信号量的区别）

```c
rt_completion_wait(&bus->dma_completion, RT_WAITING_FOREVER);//阻塞等待中断回调唤醒线程（DMA 完成）；
```

drv_spi_xfer函数：

```c
static rt_uint32_t drv_spi_xfer(struct rt_spi_device *device, struct rt_spi_message *message)
```

1)获取总线bus,获取片选 cs，获取设备config,

2)如果需要片选，拉低

3)开始传输 ：初始化发送接收DMA通道，初始化完成量 rt_completion_init(&bus->dma_completion); *//置零*

​	如果是接收模式：分配接收DMA，

​	如果是发送模式：分配发送DMA， *为发送数据申请缓冲区；**将原始 uint8_t 数据写入 32-bit 对齐缓冲区。*

​	如果同时收发： 1.注册中断函数，2. 设置spi寄存器手发模式 3. 启动dma接收发送 

​	是能片选引脚开始

4）  阻塞等待DMA中断完成，rt_completion_wait(&bus->dma_completion, RT_WAITING_FOREVER);

5） *会将通道对应的中断注册项清除。* cs拉高，释放通道信号



msd _init过程：

*具体的初始化函数还是得调用  rt_device_init(dev);这个时候才会真正执行 rt_msd_init() 的全部初始化流程（例如识别 SD 卡、初始化 SPI 协议、建立扇区信息）。*

需要实现 init  open read write  close contal 函数，

​	1） **这个时候才会真正执行 rt_msd_init() 的全部初始化流程（例如识别 SD 卡、初始化 SPI 协议、建立扇区信息）。**

​	2）*//main函数中通过fprint  fget等函数本质上会调用 MSD驱动的的read函数，然后调用rt_msd_read->根据单块还是多块调用_read_block(),多块->read_blocks()*



如何计算的125ms， 单张图片大小600*600*3  sd的最高速度4M/S 大约写完一张要120ms左右。  rt_tick_get();



4. 设计基于 DMA/IDLE/环形缓冲区的串口不定长通信驱动，并构建协议解析状态机，通过CRC16校验保证指令数据的完整性；

空闲中断中可以计算空闲终端接受了一段数据，可以计算长度*计算DMA接收的数据长度*，*// 将接收的数据存入环形缓冲区*，*// 重启DMA接收*。



5. 采用 Event+MQ 异步驱动架构，结合原子操作多线程保护，实现双车协同指令与紧急事件响应（保证传球时间控制在2s内)；

​	有一杂项线程（图像第一  几件通信第二，杂项第三（检测车的紧急事件以及双车之间的协同指令，通过event事件，通过原子变量来修改全局的目标速度来响应紧急事件响应，MQ 消息队列主要用于记录蜂鸣器响应时长的，比如...圆环  三叉 十字检测到了就设计蜂鸣器响几秒）LCD显示线程 ）

​	2S就是一个事件范围，

结合原子操作多线程保护 这里解释封装了一个函数，在内部修改全局共享面量的时候关中断修改，之后开中断

### 第三点：

基于 UART + UBlox 协议实现 CUAV Neo3 GPS 驱动，通过多线程状态机解析实现定位数据获取与解析，提供实时位置服务；

移植协议，

 */\* 设置UART接收回调函数 \*/*

 */\* 创建解析线程 \*/*

![image-20250822222144960](assets/image-20250822222144960.png)



![image-20250822222108718](assets/image-20250822222108718.png)

### 第四点

基于 DMA + 完成量机制构建 SD/SPI/FATFS 阻塞式读写驱动，实现巡检照片高效写入至 SD 卡（单张图片写入耗时**125ms**）。

移植的，

这是最根本的硬件原因。许多微控制器（MCU），尤其是中低端的Cortex-M系列芯片，**并不自带SDIO控制器**。它们通常只提供标准的SPI外设。因此，使用SPI接口驱动SD卡是**唯一的选择**。相比之下，SDIO需要芯片有专用的SDIO硬件接口。



*/**

*主要包括* 

*1.头文件配置*

*2.数据结构定义*

*3.SPI配置函数*

*4.SPI数据传输函数*

*5.SPI初始化*

**/*

#include "drv_spi.h" //本驱动的头文件
#include <drv_io_config.h>  // IO引脚配置
#include <drivers/dev_spi.h>  //SPI设备定义
#include "dmalock.h"  //DMA通道锁管理
#include <sysctl.h> //系统控制相关
#include <gpiohs.h>  //高速GPIO操作
#include <string.h> 
#include "utils.h" //实用工具



*// SPI总线数据结构*

struct drv_spi_bus

{

  struct rt_spi_bus parent;   *// RT-Thread标准的SPI总线结构*

  spi_device_num_t spi_instance;  *// SPI实例编号(0,1,2,3)*

  dmac_channel_number_t dma_send_channel;*// 发送DMA通道*

  dmac_channel_number_t dma_recv_channel; *// 接收DMA通道*

  struct rt_completion dma_completion;  *// DMA完成信号量*

};

*/**

 *//开始DMA传输逻辑*

drv_spi_xfer()

{



 *//初始化完成量对象 dma_completion，用于等待 DMA 结束。*

*占用 DMA 接收通道；*

*占用 DMA 发送通道；*

if(*message*->send_buf && *message*->recv_buf)

​    {

​      */**

​      *设置 SPI 为发送 + 接收模式（全双工）；*

​      *同时注册 发送和接收 DMA 中断回调；*

​      *启用 SPI + DMA；*

​      *设置 DMA：*

​      *接收：SPI_DR ➜ rx_buff；*

​      *发送：tx_buff ➜ SPI_DR。*

​        *注册 DMA 接收中断回调；*

​        *设置 SPI 为 收发模式；*

​        *使能 DMA 发送 + 接收；*

​        *启用 SPI 模块。*

​      **/*

​      *//注册中断函数*

​      dmac_irq_register(bus->dma_recv_channel, dma_irq_callback, &bus->dma_completion, 1);

​      *//设置spi寄存器  收发模式*

​      __spi_set_tmod(bus->spi_instance, SPI_TMOD_TRANS_RECV);

​      *//启 DMA 接收 + DMA 发送（位0 + 位1）。*

​      spi_instance[bus->spi_instance]->dmacr = 0x3;  *// 寄存器/位  dmacr = 3 含义  使能DMA发送和接收*

​      *//启用 SPI 模块。*

}



​    rt_completion_wait(&bus->dma_completion, RT_WAITING_FOREVER);*//阻塞等待中断回调唤醒线程（DMA 完成）；*

​    *//清理&后处理  注销中断。*

​    */**

​    *收完或发完后，注销中断回调，避免残留回调影响后续；*

​    *dmac_irq_unregister(channel) 会将通道对应的中断注*

## SPI 驱动  

重要的是xfer函数

初始化信息 比如完成量，舒适DMA通道，临时rxbuff等

1. 根据接收还是发送分配DMA通道， 
2. 根据收发 还是同时收发  注册dma中断函数， 设置SPI的寄存器收发模式， 启动dma收发模式设置寄存器dmacr, 启用SPI模块设置寄存器 ssienr
3. 启动传输，拉低片选
4. 等待rt_completion_wait(); dma中断完成会调用rt_completion_down，唤醒等待程序。
5. 注销终中断调函数中
6. 等待FIFO清空，*通常用于 SPI 主机在关闭片选信号前 清空发送缓存，避免截断数据。*
7. *取消片选 ser 失能；禁用 SPI 控制器 ssiner 禁止*
8. *把 rx_buff 中数据拷贝回用户 buffer*，
9. 清理资源   *释放锁；释放 malloc 分配的临时 buffer*





### SPI IIC的区别

![image-20250826215715047](assets/image-20250826215715047.png)

![image-20250826215742178](assets/image-20250826215742178.png)

![image-20250826225213801](assets/image-20250826225213801.png)

🧠也就是说  xfer控制的发送和接收是对dr[36]操作的 数据寄存器，是在 地址和数据总线上的。 可以通过读取“数据寄存器 DR”，可以获取接收缓冲区中的内容。  通过写 SPI 的“数据寄存器 DR”把数据填充到发送 F 缓冲区中，

```c
            /*设置 DMA 接收：SPI 接收寄存器 ➜ rx_buff；设置 DMA 发送：tx_buff ➜ SPI 发送寄存器。*/  
            //    /* SPI Data Register 0-36    (0x60 -- 0xec)      volatile uint32_t dr[36]; */
            //通道   源地址  目的地址
            /*
            void dmac_set_single_mode(
                dmac_channel_number_t channel,       // DMA 通道号
                void *src,                           // 源地址
                void *dst,                           // 目的地址
                dmac_addr_increment_t src_inc,      // 源地址是否自增
                dmac_addr_increment_t dst_inc,      // 目的地址是否自增
                dmac_msize_t dmac_msize,            // 总线突发大小（一次搬几个）
                dmac_transfer_width_t trans_width,  // 传输单位宽度（字节/半字/字）
                size_t block_size                   // 总传输数量（单位个数，不是字节）
            );
            */
            dmac_set_single_mode(bus->dma_recv_channel, (void *)(&spi_instance[bus->spi_instance]->dr[0]), rx_buff, DMAC_ADDR_NOCHANGE, DMAC_ADDR_INCREMENT,
                           DMAC_MSIZE_1, DMAC_TRANS_WIDTH_32, message->length);
```

![](assets/image-20250826215756016.png)

![image-20250826220000957](assets/image-20250826220000957.png)

可以是半双工   

​	只用MOSI ：发送时 地址和数据总线将数据写到发送缓冲区-》移位寄存器-》发送

​				接受时 从MOSI接收-》数据经过移位寄存器-》接收缓冲区。

![image-20250826220646211](assets/image-20250826220646211.png)

![image-20250826220726309](assets/image-20250826220726309.png)

可能是奇数边沿MOSI  MISO 寄存器变化，偶数边沿采样

![image-20250826221024195](assets/image-20250826221024195.png)

![image-20250826221202296](assets/image-20250826221202296.png)



![image-20250826221749633](assets/image-20250826221749633.png)



### SPI config  配置都配置什么（SPI_CR0寄存器）

​	片选



 	 时钟（CPOL）  相位(CPHA)  

​	工作模式（0~3）

​	 数据位宽

* 设置SPI时钟频率*波特率

![image-20250826224515803](assets/image-20250826224515803.png)



![image-20250826224556802](assets/image-20250826224556802.png)

![image-20250826224626963](assets/image-20250826224626963.png)



#### 状态寄存器

 通过读取状态寄存器判断接受的状态：

![image-20250826224728948](assets/image-20250826224728948.png)



### 数据寄存器

![image-20250826224837244](assets/image-20250826224837244.png)





#### 整个过程

主要遵循发送一位 接受一位； 整个都是SPI主机的图，软件向dr中写入一个数据，等待MOSI发送完TXE，然后接受等待RXNE=1从SPI_DR中读取数据。等待MOSI发送完TXE，然后接受等待RXNE=1从SPI_DR中读取数据。

![image-20250826230133944](assets/image-20250826230133944.png)



主模式收发流程及事件说明如下：

1. 控制 NSS 信号线，产生起始信号 (图中没有画出)；
2. 把要发送的数据写入到“数据寄存器 DR”中，该数据会被存储到发送缓冲区；
3. 通讯开始，SCK 时钟开始运行。MOSI 把发送缓冲区中的数据一位一位地传输出去；MISO则把数据一位一位地存储进接收缓冲区中

(4) 当发送完一帧数据的时候，“状态寄存器 SR”中的“TXE 标志位”会被置 1，表示传输完一帧，发送缓冲区已空；类似地，当接收完一帧数据的时候，“RXNE 标志位”会被置 1， 表示传输完一帧，接收缓冲区非空；

(5) 等待到“TXE 标志位”为 1 时，若还要继续发送数据，则再次往“数据寄存器 DR”写入数据即可；等待到“RXNE 标志位”为 1 时， 通过读取“数据寄存器 DR”可以获取接收缓冲区中的内容。

假如我们使能了 TXE 或 RXNE 中断，TXE 或 RXNE 置 1 时会产生 SPI 中断信号，进入同一个中断服务函数， 到 SPI 中断服务程序后，可通过检查寄存器位来了解是哪一个事件，再分别进行处理。也可以使用 DMA 方式来收发“数据寄存器 DR”中的数据。



### 1.3. 软件SPI与硬件SPI的区别

1.3.1. 软件SPI

软件SPI需要用IO口模拟时序，这个模拟过程全部由CPU完成，为了能稳定的存入数据，可能插入软件延时，这个时间在读取数据量小的情况下不明显， 但是基本上你在读取过程中其他非中断、非异常程序是无法得到执行的。

1.3.2. 硬件SPI

硬件SPI数据存储过程是不需要CPU参与的，程序中配置好SPI的访问时序，开启中断，CPU就可以在中断函数中搬移数据，省下了软件模拟IO的存取时间。 这一节介绍的内容就是硬件SPI。

当然，不能认为硬件SPI速度快，在做项目时就一定要用它，这需要根据实际情况而定。



## I2C协议

![image-20250826230830085](assets/image-20250826230830085.png)



![image-20250826231107803](assets/image-20250826231107803.png)

同步串行半双工 

![image-20250826231416803](assets/image-20250826231416803.png)

![image-20250826231510705](assets/image-20250826231510705.png)



挂在在总线上的设备都有自己唯一的ID

![image-20250826231604527](assets/image-20250826231604527.png)

1. 它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。
2. 一个 I2C 总线只使用两条总线线路，一条双向串行数据线 (SDA) ，一条串行时钟线 (SCL)。数据线即用来表示数据，时钟线用于数据收发同步。
3. 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。
4. 总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。
5. 多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。
6. 具有三种传输模式：标准模式传输速率为 100kbit/s ，快速模式为 400kbit/s ，高速模式下可达 3.4Mbit/s，但目前大多 I2C 设备尚不支持高速模式。
7. 连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制。



![image-20250826232000793](assets/image-20250826232000793.png)



!![image-20250826232411953](assets/image-20250826232411953.png)



字节必须是8位  必须是MSB（高位先发）应答信号低电平。

![image-20250826232700275](assets/image-20250826232700275.png)



![image-20250826232719446](assets/image-20250826232719446.png)

#### 地址 

起始信号产生后，所有从机就开始等待主机紧接下来广播的从机地址信号 (SLAVE_ADDRESS)。在I2C 总线上， 每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，这个设备就被选中了， 没被选中的设备将会忽略之后的数据信号。根据 I2C 协议，这个从机地址可以是 7 位或 10 位。

#### 读写

在地址位之后，是传输方向的选择位，该位为 0 时，表示后面的数据传输方向是由主机传输至从机，即主机向从机写数据。该位为 1 时，则相反，即主机由从机读数据。

从机接收到匹配的地址后，主机或从机会返回一个应答 (ACK) 或非应答 (NACK) 信号，只有接收到应答信号后，主机才能继续发送或接收数据。



#### 写数据

**写数据** 若配置的方向传输位为“写数据”方向，即第一幅图的情况，广播完地址，接收到应答信号后， 主机开始正式向从机传输数据 (DATA)，数据包的大小为 8 位，主机每发送完一个字节数据， 都要等待从机的应答信号 (ACK)，重复这个过程，可以向从机传输 N 个数据，这个 N 没有大小限制。 当数据传输结束时，主机向从机发送一个停止传输信号 (P)，表示不再传输数据。



### 读数据

若配置的方向传输位为“读数据”方向，即第二幅图的情况，广播完地址，接收到应答信号后，从机开始向主机返回数据 (DATA)， 数据包大小也为 8 位，从机每发送完一个数据，都会等待主机的应答信号 (ACK)，重复这个过程， 可以返回 N 个数据，这个 N 也没有大小限制。当主机希望停止接收数据时，就向从机返回一个非应答信号 (NACK)，则从机自动停止数据传输。

![image-20250826233555084](assets/image-20250826233555084.png)

![image-20250826233601611](assets/image-20250826233601611.png)

![image-20250826233648547](assets/image-20250826233648547.png)



STM32 的 I2C 外设可用作通讯的主机及从机，支持 100Kbit/s 和 400Kbit/s 的速率，支持 7 位、10位设备地址，支持 DMA 数据传输， 并具有数据校验功能。它的 I2C 外设还支持 SMBus2.0 协议，SMBus 协议与 I2C 类似，主要应用于笔记本电脑的电池管理中，本教程不展开， 感兴趣的读者可参考《SMBus20》文档了解。

![image-20250826233749168](assets/image-20250826233749168.png)















## CAN





## USB





## uart（RS-232 RS-485 RS-422）

串口只是一个泛称，以上几种都遵循雷迪的通信时需协议，被称为串口。

![image-20250826214534828](assets/image-20250826214534828.png)

![image-20250826214558112](assets/image-20250826214558112.png)

![image-20250826214457873](assets/image-20250826214457873.png)

![image-20250826214809575](assets/image-20250826214809575.png)

![image-20250826214847826](assets/image-20250826214847826.png)

![image-20250827094744015](assets/image-20250827094744015.png)

![image-20250827094932913](assets/image-20250827094932913.png)

![image-20250827095138247](assets/image-20250827095138247.png)





RS485(半双工)



工控-

![image-20250827095305374](assets/image-20250827095305374.png)

![image-20250827095318149](assets/image-20250827095318149.png)

![image-20250827095529946](assets/image-20250827095529946.png)

![image-20250827095845870](assets/image-20250827095845870.png)

![image-20250827095856188](assets/image-20250827095856188.png)

![image-20250827100113304](assets/image-20250827100113304.png)

![image-20250827100256853](assets/image-20250827100256853.png)

## CAN

![image-20250827100605784](assets/image-20250827100605784.png)

![image-20250827100741518](assets/image-20250827100741518.png)

 

![image-20250827100942947](assets/image-20250827100942947.png)

![image-20250827101129907](assets/image-20250827101129907.png)

IIC是由主机发送开始信号才能进行通信



Can 每一个设备都可以主动发送数据

![image-20250827101333637](assets/image-20250827101333637.png)

### 物理层

![image-20250827101438054](assets/image-20250827101438054.png)

显性电平0

![image-20250827101534877](assets/image-20250827101534877.png)

![image-20250827101651188](assets/image-20250827101651188.png)

![image-20250827101714649](assets/image-20250827101714649.png)

![image-20250827101732702](assets/image-20250827101732702.png)

### 协议层

一帧一帧的，五种类型帧，

数据帧：发送单元向接受单元发送数据

遥控帧： 用于接收方向具有相同ID的发送方发送请求数据的帧（告诉别人你可以发了）

错误帧：检测出错误想起他单元发送错误帧（告诉别人出错了）

过载帧：接受单元通知其尚未做好接受准备的帧（告诉别人你发的太快了）

间隔帧：数据帧  遥控帧与前面分离开来的帧

​    

![image-20250827102525538](assets/image-20250827102525538.png)

#### 数据帧

有七段组成  标准真和扩展帧

 ![image-20250827102728815](assets/image-20250827102728815.png)

帧起始：0 显性电平（表示数据帧开始）

仲裁段： ID 表示帧优先级的段 11bit

​		RTR 远程发送请求位   0 ： 数据帧   1：遥控帧 （区别在于有没有数据）

![image-20250827103121787](assets/image-20250827103121787.png)

控制段： DLC ：表示数据的字节数 数据长度编码

​		IDE：扩展标识符位（ 标准还是扩展帧）

​		R0: 

数据段： 0~64bit  (0~8字节)

![image-20250827103542336](assets/image-20250827103542336.png)

CRC：15bit校验  帧传输错误

ACK ：确认正常接收的段、（发送时是1 ，当接收到了设备会置0）

真结束：7个隐形型号

![image-20250827104424336](assets/image-20250827104424336.png)

#### 位时序

位同步机制  实现对电平的正确采样。（没有时钟  只有差分）

  ![image-20250827110221163](assets/image-20250827110221163.png)

![image-20250827110345683](assets/image-20250827110345683.png)

![image-20250827110501897](assets/image-20250827110501897.png)



 

![image-20250827105326189](assets/image-20250827105326189.png)

![image-20250827105431032](assets/image-20250827105431032.png)

![image-20250827105448870](assets/image-20250827105448870.png)

![image-20250827105527158](assets/image-20250827105527158.png)

![image-20250827105753408](assets/image-20250827105753408.png)

![image-20250827105822991](assets/image-20250827105822991.png)

![image-20250827111232059](assets/image-20250827111232059.png)

## Git命令

![image-20250827112052945](assets/image-20250827112052945.png)

![image-20250827112147475](assets/image-20250827112147475.png)

![image-20250827112221314](assets/image-20250827112221314.png)

![image-20250827112228211](assets/image-20250827112228211.png)

![image-20250827112324988](assets/image-20250827112324988.png)

![image-20250827112434225](assets/image-20250827112434225.png) 

![image-20250827113432731](assets/image-20250827113432731.png)

![image-20250827113549222](assets/image-20250827113549222.png)

#### 1. git fetch

**有什么用？**

`git fetch` 的核心作用是：**从远程仓库下载最新的提交历史、分支和标签到你的本地仓库，但不会自动合并或修改你当前的工作。**

你可以把它想象成 **“检查远程服务器上有什么更新”** 的操作。

- **它下载什么？** 它会获取所有你本地还没有的远程分支（比如 `origin/main`, `origin/feature`）的最新提交和其他数据。
- **它改变什么？** 它**不会**改变你本地的任何文件、你的当前分支（如 `main`）或你的工作目录。它只是更新了本地的“远程跟踪分支”（如 `origin/main`），让你能看到远程仓库的最新状态。

**为什么需要它？**
在团队协作中，其他同事可能已经向远程仓库推送了他们的代码。在你开始工作之前或之后，使用 `git fetch` 可以让你了解远程仓库的最新情况，而不会影响你手头正在做的工作。

**常用命令：**

- `git fetch`：获取所有远程仓库的更新。
- `git fetch origin`：获取名为 `origin` 的远程仓库的更新。
- `git fetch origin main`：只获取远程 `origin` 的 `main` 分支的更新。





1. **这时，你该用 `git fetch` 了**：
   你想知道：“图书馆的书有没有什么新变化？我的同事有没有提交新内容？”
   于是你执行了 `git fetch`。这个命令就像是：**你派了一个秘书跑去图书馆，把最新的目录和更新了的章节复印回来，放在你书桌的另一个文件夹里（这个文件夹叫 `origin/main`），然后告诉你：“老板，图书馆的书更新了，这是最新情况。”**

   **重点：**

   - **秘书没有动你正在写的稿子！** 你的**章节3**还好好的在那儿。
   - 秘书只是把图书馆的新内容**报告**给了你。你现在**知道**了图书馆的新版本，但还没有把它和你手头的工作合并。

**所以，`git fetch` 的作用就是：安全地、不打扰你工作地，去检查远程仓库有什么新东西。它只“看”不“改”。**





###  3. git rebase

**有什么用？**

`git rebase` 的核心作用是：**重新设置你当前分支的“基址”。** 它是一种整合来自不同分支的修改的方法，通常用于让提交历史变得更加清晰线性。

它的工作方式可以理解为 **“把我的修改接到别人最新工作的后面”**。

假设你的提交历史是这样的（`main` 是主分支，`feature` 是你的特性分支）：

text

```
      A---B---C feature
     /
D---E---F---G main
```

- **如果你在 `feature` 分支上执行 `git rebase main`：**
  1. Git 会首先找到 `feature` 和 `main` 分支的共同祖先（提交 E）。
  2. 然后临时保存你的特性分支上的所有修改（A, B, C）。
  3. 将 `feature` 分支的指针快速移动到 `main` 分支的最新提交（G）上。
  4. 最后，把你保存的修改（A, B, C）依次在 G 之后重新应用一遍。

最终的历史会变成一条干净的直线：

text

```
              A'--B'--C' feature
             /
D---E---F---G main
```

**为什么需要它？**

- **更清晰的历史：** 避免了不必要的合并提交（merge commit），使项目历史看起来像按时间顺序直线发展的，更容易阅读和理解。
- **在合并前更新分支：** 在将你的分支合并回主分支之前，先变基到最新的主分支上，可以确保你的代码是基于最新的代码开发的，减少冲突的可能性。

**注意：** Rebase 会重写提交历史，因此**绝对不要**对已经推送到远程仓库并与他人共享的分支执行变基操作，这会给协作者带来极大的混乱。

![image-20250827141829476](assets/image-20250827141829476.png)

![image-20250827141931179](assets/image-20250827141931179.png)





![image-20250827142057446](assets/image-20250827142057446.png)

```c
# 1. 添加所有更改到暂存区
git add .

# 2. 创建提交
git commit -m "修复了登录页面的按钮样式"

# 3. 先检查一下远程仓库有没有别人推送的新代码（只查看，不自动合并）
git fetch

# 4. 查看状态，这会告诉你当前分支和远程分支的对比情况
git status

# 根据 `git status` 的提示：
# 如果显示 `Your branch is ahead of 'origin/main' by 1 commit.`，说明只有你一个人有提交，可以直接push。
# 如果显示 `Your branch and 'origin/main' have diverged...`，说明远程也有新提交，你需要整合。

# 5. 如果远程有更新，就用rebase进行整合
git rebase origin/main  # 或者直接用 `git pull --rebase`

# 6. 确认无误后，推送到远程
git push
```

![image-20250827142343803](assets/image-20250827142343803.png)





# 北方华创

## 工作要求：

![image-20250828100428601](assets/image-20250828100428601.png)

看着是相中了QT 功能；



**描述：**本项目基于 ROS+QT+LLM 开发一套智能机器人仿真平台，实现自然语言文本→LLM任务规划→机器人动作执行闭环控制。

**技术栈：UR3、ROS1（C++/CMake/Python）、QT（Network/Json/Thread）、Dify（Docker）、LLM、Gazebo**

- 开发基于 Qt5 的智能机器人交互系统，集成 LLM 任务规划、指令下发、日志存储与实时监控等功能，实现高效的人机协同作业；
- 基于Dify+LLM构建语义解析引擎，实现非结构化自然语言指令到机械臂运动序列的精准转换，组装任务解析准确率达到 91.3%；
- 开发智能语言控制中间件，通过对动作序列的解析和分发，实现其到 ROS 指令的实时转换，并具备自动执行和异常处理等功能。





## 自我介绍



面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读控制科学与工程专业硕士学位，本科毕业于东华大学自动化专业。

我的技术方向主要集中在嵌入式系统和软件开发方面。能够熟练使用C/C++进行编程。具体来说，第一块是嵌入式实时系统，像RT-Thread这类系统，我有多线程架构的设计和开发经验；第二块是多源数据融合和运动控制，能够处理多种传感器信息，实现比较精准的协同控制；第三块是通信协议，熟悉UART、SPI、I2C这些常用硬件协议，做过基于状态机的解析机制；最后也做过机器人智能交互相关开发，包括用Qt做界面，以及大模型集成和任务规划。

在近期项目中，我主要负责基于智能交互机器人综合抓取平台的开发，基于ROS, Gazebo，大语言模型，QT等多个模块，实现了自然语言文本指令到 任务序列规划、指令下发、日志存储与实时监控等功能界面，提升了人机协同作业的效率。

通过项目实践，我不仅积累了Qt跨平台开发经验，深入理解了信号槽机制、多线程处理以及数据交互等关键技术，能够独立完成功能设计和测试工作。同时，我也具备嵌入式系统、实时操作系统及硬件通信协议方面的基础，能更好地支持机台控制程序的开发与调试。期待能加入贵公司，为机台控制与软件开发贡献自己的力量。

































2.北方华创。月18K（基本工资15.6K，绩效5.4K）。年终奖2~4个月工资。算下来一年25W~28W。有大兴户口，没有事业编制。宿舍四人间。hr说项目紧才加班，网上说加班多，有加班费。北方华创也算是国内半导体行业的龙头了。

















## ❓ 为什么投华创？

回答要点：

1. **行业地位**：北方华创是国内头部半导体设备公司，行业认可度高，发展前景大。
2. **岗位契合**：岗位和你的技能背景高度匹配（控制软件、C++/Qt、RTOS/ROS 等）。
3. **成长机会**：华创在半导体装备国产化进程中承担重要角色，你能接触最前沿的技术和项目。
4. **价值认同**：你希望通过软件研发参与到“卡脖子”关键设备国产化进程。

✅ 示例答法：

> 我投递华创主要有两个原因。第一，华创是国内领先的半导体装备企业，在刻蚀机、清洗机等领域处于行业前沿，代表着国产设备突破“卡脖子”环节的核心力量。我希望能在这样的平台中发挥所长。第二，岗位要求和我的背景非常契合，比如我在研究中做过机器人控制、RTOS 驱动和 ROS+Qt 的工业软件开发，这些都和机台控制软件研发有相通之处。我希望在华创的平台上进一步提升工程能力，也为国产设备的发展贡献力量。

华创是国内领先的半导体设备企业，在行业里有很强的技术实力。第二，岗位要求和我的背景非常契合，比如我在研究中做过机器人控制， ROS+Qt 的工业软件开发，这些都和机台控制软件研发有相通之处。我希望在华创的平台上进一步提升工程能力，也为国产设备的发展贡献力量。



## ❓ 如何了解到华创的？

回答要点：

1. **信息渠道**（要真实，比如）：
   - 学校宣讲会 / 校招官网 / BOSS直聘 / 牛客网 / 学长推荐 / 实习经历。
   - 结合你科研方向（机器人、工业控制），了解到华创在半导体设备领域的软件需求。
2. **兴趣驱动**：你不是随便海投，而是有意识关注国产半导体设备企业。

✅ 示例答法：

> 我最初是通过学校的宣讲会和官方校招信息了解到华创的，后来又结合学长的推荐和一些行业报道，对公司有了更深入的认识。我了解到华创在半导体设备国产化中处于领军位置，特别是在等离子刻蚀、PVD、CVD 等设备软件研发上有很高的技术要求。这让我觉得，自己在机器人和工业控制方向积累的经验，正好可以和华创的业务产生结合点，所以选择投递。

我主要是通过学校的宣讲会和校招信息了解到华创的，也结合行业报道进一步了解了公司的发展情况。



## 业务问题

**业务问题：**

你用过git进行，知道git merge和git rebase的区别吗？

C++多态如何实现？

对包含有一个int a的类或者类实例进行sizeof（），获取到的大小是多少，如果类中有虚函数呢？虚函数指针和虚函数表存储在哪里？

TCP的全连接队列和半连接队列、TCP的TIME-WAIT状态是什么？

用过哪些STL容器，分别用来存储什么类型的数据？

vector持续push_back操作会导致什么？扩容的过程是什么？

unordered_map在使用时可能发生什么问题？哈希冲突的两种解决方法？

map是用红黑树存储数据，数据查找的时间复杂度是什么？

c语言定义一个char类型的字符串数组，大小为20，使用strcopy往这个数组中拷贝字符串时需要注意什么？



##  反问

最后我想再请教一下：咱们部门目前在软件方面的主要业务方向是什么？另外，对于新人是否会有系统的培养计划或导师带教机制呢？





我想再确认一下，咱们软件工程师的工作主要是集中在北京总部吗？另外，接下来的招聘流程大概是怎样安排的呢？





![image-20250902102057258](assets/image-20250902102057258.png)







## ✅ HR 问题答法参考

1. **家庭情况**

> 我的家人都非常支持我在北京发展，所以工作上没有后顾之忧。

1. **个人单身状况**

> 目前是单身，精力主要放在工作和提升自己上。

1. **接受什么样的工作强度**

> 我能接受正常的加班或者项目节点需要的投入，只要合理安排，保证效率和质量没有问题。

1. **职业规划**

> 短期希望尽快适应岗位，积累设备软件研发的经验；长期希望能在半导体装备软件方向深入，成长为独立负责模块的骨干工程师。

1. **期望薪资**

> 我主要看重岗位发展和学习机会，薪资希望能按照公司校招的统一标准来。

1. **工作地点**

> 北京完全没有问题，我也希望能在北京这样的研发氛围里长期发展。

1. **有没有拿到 offer**

> 目前还在面试阶段，华创是我非常看重的机会，所以我希望能优先考虑。

1. **找工作主要看重那几点**

> 我主要看重三个方面：岗位和自身背景的匹配度、公司的行业地位与发展前景，以及个人成长的空间。

1. **为什么投华创**

> 华创是国内领先的半导体设备企业，在行业里有很强的技术实力。岗位和我的研究背景（控制软件、工业方向）很契合，所以希望能加入。

1. **如何了解到华创的**

> 一方面是通过学校宣讲和校招信息，另一方面也通过行业报道和学长的推荐，对公司有了进一步了解。
>
> 





# 汇顶科技

## linux的启动流程

**核心就是：固件 -> 引导 -> 内核 -> systemd -> 登录**

```
问题 31：linux 启动流程？
阶段 1: Bootloader (引导加载程序)
这是启动的序幕，完全在操作系统之外运行。

硬件初始化：CPU 上电后，从预设地址（通常是芯片的 ROM）执行第一段代码，称为 BootROM。它初始化最基础的硬件（如时钟、内存控制器），然后加载下一阶段的引导程序。

Primary Bootloader：例如 U-Boot、GRUB、或芯片厂商提供的工具。它的核心职责是：

初始化更多硬件：如存储设备（eMMC、SD卡）、网络（用于网络启动）、显示屏等。
定位内核映像：从存储设备或网络上找到 Linux 内核镜像（zImage、uImage或 Image）和可选的初始内存磁盘（initramfs或initrd）。

加载到内存：将内核和 initramfs加载到指定的物理内存地址。

传递参数：准备并传递启动参数给内核，最重要的是 设备树（Device Tree Blob, DTB） 的地址（在 ARM 等架构上）或命令行参数（cmdline）。

跳转到内核：最终将 CPU 的执行权交给内核的入口点。

阶段 2: 内核初始化阶段

内核开始执行，但此时还在解压和进行最基础的初始化。
内核解压与入口：如果内核是压缩过的（如 zImage），首先会运行一段小代码进行自解压，然后跳转到真正的内核入口函数（通常是 _start或 stext）。
架构相关初始化：在内核入口函数中，进行非常底层的 CPU 和平台相关初始化：
设置异常向量表。
初始化 MMU（内存管理单元），开启虚拟内存。这是一个关键转折点，之后内核将运行在虚拟地址空间。
检测 CPU 拓扑结构。
通用内核初始化 (start_kernel)：这是 Linux 内核初始化的主函数，它初始化了几乎所有内核子系统：
设置陷阱（Trap）、中断（IRQ）。
初始化调度器：为初始线程（0号进程，即 idle进程）初始化调度器。
初始化内存管理（mm_init）：建立完整的内存管理数据结构，伙伴系统开始工作。•初始化内核的 initramfs：如果存在，将其解压并准备好。
初始化 VFS（虚拟文件系统）：为后续挂载真实文件系统做准备。
初始化设备模型（driver_init）：建立总线、设备、驱动的模型框架。
解析启动参数：处理从 Bootloader 传来的 cmdline。
初始化早期外设和中断。
创建第一个用户态进程：在 start_kernel的最后，会调用 rest_init函数，该函数会创建两个内核线程： 
kernel_init：1号进程（init进程）的雏形，它是所有用户进程的祖先。
kthreadd：2号进程，负责调度和创建其他内核工作线程。

阶段 3: 内核启动阶段 (kernel_init)
这个阶段由 kernel_init内核线程执行，它负责完成启动的“临门一脚”。
等待kthreadd初始化完成。
加载并挂载 initramfs：如果使用了 initramfs，内核会将其解压并挂载为临时的根文件系统。initramfs包含一个精简的用户空间，包含了挂载真实根文件系统所必需的工具和驱动（如加密模块、RAID 驱动、非标准文件系统驱动等）。
执行 initramfs中的 /init：initramfs中的第一个程序通常是 /init（一个脚本或可执行文件）。它负责：
加载必要的内核模块（驱动）。
识别真正的根文件系统设备（如 /dev/mmcblk0p2）。
可能涉及解密、逻辑卷管理（LVM）等复杂操作。
最后，将根文件系统切换（pivot_root） 到真实的根文件系统上。
执行真实的 /sbin/init：在真实的根文件系统被挂载后，kernel_init会尝试执行根文件系统上的 /sbin/init（这是传统的 1 号进程）。此时，内核的启动任务完成，控制权完全交给用户空间。


阶段 4: 用户空间初始化 (Systemd)
这是由 /sbin/init（通常是 systemd）主导的阶段。
Systemd (现代主流)：
解析配置：读取 /etc/systemd/system和 /lib/systemd/system等目录下的单元文件（.service, .target等）。
启动目标（Target）：默认会进入 default.target（通常链接到 graphical.target或 multi-user.target）。
并行启动服务：根据依赖关系，尽可能并行地启动所有需要的系统服务（如 sshd, dbus, getty等）。
资源管理：通过 cgroups管理进程组资源。
阶段 5: 登录界面
系统初始化的最后一步是启动登录管理器。
Getty 或 Display Manager：
在文本模式下，init会启动多个 getty进程，监听 tty1-tty6，显示 login:提示符。
在图形模式下，会启动显

```





```
阶段一：BIOS/UEFI 阶段（硬件初始化）
1. 加电自检：计算机通电后，主板上的固件（BIOS 或现代的 UEFI）开始运行。它检测和初始化关键硬件，如 CPU、内存、磁盘、显卡等。
2. 寻找引导设备：POST 完成后，固件按照预设的启动顺序（如：硬盘、U盘、光驱、网络）寻找可引导的设备。
3.读取主引导记录 (MBR) 或 EFI 分区：
		BIOS+MBR：从启动设备的第一个扇区（512字节）读取 MBR。MBR 包含一小段引导代码（446字		节）和分区表。
        UEFI+GPT：UEFI 固件直接从硬盘上的 EFI 系统分区 (ESP) 中查找并执行已注册的引导程序应		  用程序（如 grubx64.efi）。这种方式更现代、更强大。
阶段二：引导程序阶段（GRUB2）
1. 引导加载程序执行
	显示一个启动菜单，让用户选择要启动的操作系统或内核版本。
	加载所选版本的 Linux 内核镜像（/boot/vmlinuz-xxx）到内存中。
	同时，将初始 RAM 磁盘镜像 (initramfs/initrd) 加载到内存。这个镜像包含了启动早期所必需的	核心驱动（如文件系统、磁盘控制器驱动）和工具。
阶段三：内核初始化阶段
1.内核解压与初始化
	内核被加载到内存后，首先进行自解压，然后开始初始化。
	关键任务：
    初始化 CPU、内存管理等核心子系统。
	设置虚拟地址空间，为进程调度做准备。
	注意：此时内核还无法访问真正的根文件系统，因为磁盘控制器和文件系统的驱动可能还在 initramfs 		里。
2.挂载 initramfs 并执行 /init
	动作：内核将 initramfs 解压为一个临时的根文件系统（rootfs）并挂载它。
阶段四：系统初始化与用户空间启动 (systemd 或 SysV init)
1.启动 init 进程 (PID 1)
动作：内核在挂载根文件系统后，会尝试执行第一个用户空间进程，它的进程号永远是 1。
2.systemd 的工作流程（现代主流）
读取 /etc/systemd/system/default.target，确定系统要进入的运行级别（target），常见的有： 多用户命令行模式。图形界面模式。
阶段五：登录界面

```

![image-20250904145443619](assets/image-20250904145443619.png)

![image-20250904145732006](assets/image-20250904145732006.png)

![image-20250904152521333](assets/image-20250904152521333.png)

![image-20250904152758758](assets/image-20250904152758758.png)



1. 问了面试题
2. 问了编译器 gcc along 还用过其他编译器吗
3. qt 的问题  
4. 编程代码中的问题   （int）num + 0.5  强转
5. QT的qthread 直接调用run不会出现问题吗
6. 





# 开立医疗面经





掌握面向对象设计方法和常见的设计模式。









2. 多态的实现原理

   ```
   静态多态： 函数重载，编译期就确定
   
   动态多态： 虚函数，vitural,运行时确定，
   实现方式：
   	类中存在虚函数时，编译器会为类生成一张 虚函数表（vtable）。
   	每个对象中存放一个指向该表的 虚函数指针（vptr）。
   	调用虚函数时，通过 vptr → vtable → 函数地址 来动态绑定。
   ```

   

3. 虚函数表存放在哪里

​	

```
虚函数表（vtable） 是编译器为类生成的，存放在 只读数据段（.rodata） 或 全局区。

每个类只有一张 vtable（继承链情况除外），不会为每个对象都生成。
```



2. 虚函数指针存放在哪里

   ```
   每个对象实例内部，会额外存放一个隐藏的指针成员，即 vptr。
   
   通常位于对象内存布局的起始位置（具体由编译器实现）。
   
   当对象构造时，编译器在构造函数里负责初始化 vptr 指向正确的 vtable。
   ```

   

3. 讲一讲内存的分布

   注意代码段中存放程序指令  常量字符串 和虚函数表

```
内核保留区
--------------------
栈 (stack)       // 局部变量、函数调用栈帧
--------------------
堆 (heap)        // new / malloc 分配的动态内存
--------------------
BSS 段           // 未初始化的全局变量、静态变量
--------------------
数据段 (data)    // 已初始化的全局变量、静态变量
--------------------
代码段 (text)    // 程序指令、常量字符串、虚函数表

```



2. 堆和栈的区别

   ![image-20250905171906708](assets/image-20250905171906708.png)

3. 手撕一个类，完成其拷贝构造函数和

   ```c++
   #include<iostream>
   class Mystring
   {
       private :
       	char * data;
       public:
       //构造函数
       Mystring(const char* s="")
       {
           data=new  char[strlen(s)+1] ; //strlen()不计算\0  申请的时候加上
           strcpy(data,s); // 字符串的赋值只能用strcpy(目的，源)
       }
       //拷贝构造 深拷贝
       Mystring (const Mystring &other)
       {
           data= new char[strlen(other.data)+1];
           strcpy(data,other.data);
       }
       //析构函数
       ~Mystring()
       {
           delete[] data;
       }
   }
   ```

   

4. 为什么要写拷贝构造？知道深拷贝和浅拷贝的区别吗？



```c
默认的拷贝构造函数是浅拷贝（）逐字节复制，导致多个对象指向同一块堆内存，析构时会出现 doubule free;

深拷贝，重新开辟一块堆内存，把内容复制过去，保证对象之间的独立性。
    
    写拷贝构造的原因：
    管理资源： 堆内存，文件句柄
    避免浅拷贝引起的选空指针、内存错误。
```



2. 讲一讲智能指针？



```c
智能指针是一个类模板，封装了原始指针，实现自动管理内存：
    出作用域时，自动调用 delete

	避免手动释放带来的内存泄漏/悬空指针
常见智能指针：
std::unique_ptr：独占式，禁止拷贝，只能转移（move）
std::shared_ptr：引用计数型，多个指针共享同一资源
std::weak_ptr：弱引用，不增加计数，用来解决循环引用    
```



2. share_ptr的原理？

![image-20250905173844925](assets/image-20250905173844925.png)

2. 计数器在哪里？（堆上，每个share对象会有指针指向这块内存）

![image-20250905173907323](assets/image-20250905173907323.png)

2. 那什么时候计数器开辟？

![image-20250905173925897](assets/image-20250905173925897.png)



1. 代码到可执行程序的四个阶段，虚函数表在哪个阶段创建

![image-20250905174244979](assets/image-20250905174244979.png)



2.  面向对象七大设计原则

![image-20250905174313934](assets/image-20250905174313934.png)

3.  顺序容器和关联式容器的区别

![image-20250905174333572](assets/image-20250905174333572.png)

![image-20250905174426804](assets/image-20250905174426804.png)

![image-20250905174443322](assets/image-20250905174443322.png)

4. map 的底层实现

![image-20250905174512286](assets/image-20250905174512286.png)

5. 发生死锁的四个条件

![image-20250905174530153](assets/image-20250905174530153.png)

6. 红黑树的特点，与普通二叉平衡树的区别

![image-20250905174544656](assets/image-20250905174544656.png)

7. 内存泄漏和内存碎片，如何解决

![image-20250905174557231](assets/image-20250905174557231.png)

8. 用内存池具体如何解决内存碎片

![image-20250905174619384](assets/image-20250905174619384.png)

9. 栈区的大小，什么是栈溢出，什么情况用到栈

![image-20250905174632581](assets/image-20250905174632581.png)

11. 同步和异步的区别

![image-20250905174648872](assets/image-20250905174648872.png)

12.  有哪些实现同步的方法，各自是如何实现的

![image-20250905174702172](assets/image-20250905174702172.png)

13. 了解哪些设计模式，各自的作用

![image-20250905174810065](assets/image-20250905174810065.png)
